#!/usr/bin/perl
use strict;
use warnings;

use DBI;
use DBD::Pg;
use Time::HiRes qw(time sleep);
use Data::Dumper;
use DateTime;

$| = 1;

my @Connect       = ("dbi:Pg:", '', '', {pg_enable_utf8 => 1, sslmode => 'require', RaiseError => 1, PrintError => 0, AutoCommit => 1});

my @LISTENConnect = ("dbi:Pg:", '', '', {pg_enable_utf8 => 1, sslmode => 'require', RaiseError => 1, PrintError => 0, AutoCommit => 1});
my $LISTENName = 'cron.Dispatch()';

sub SQL_Run {
    my $ProcessID = shift;
    die "Invalid ProcessID: $ProcessID" unless $ProcessID =~ m/^\d+$/;
    return "SELECT RunInSeconds FROM cron.Run(_ProcessID := $ProcessID)";
}

sub tprint {
    my $msg = shift;
    print DateTime->now(time_zone => 'local')->datetime() . ' ' . $msg . "\n";
}

my $Processes = {};

my $ConnectTime -= time();
my $DispatchDatabaseHandle = DBI->connect(@Connect) or die "Unable to connect";
$ConnectTime += time();
my $Terminate_All_Backends = $DispatchDatabaseHandle->prepare('SELECT cron.Terminate_All_Backends()');
my $Terminate_Backend      = $DispatchDatabaseHandle->prepare('SELECT cron.Terminate_Backend(_PID := $1)');
my $Reset_RunAtTime        = $DispatchDatabaseHandle->prepare('SELECT cron.Reset_RunAtTime()');
my $Waiting_PIDs           = $DispatchDatabaseHandle->prepare('SELECT cron.Waiting_PIDs()');
my $Log_Waiting            = $DispatchDatabaseHandle->prepare('SELECT cron.Log_Waiting(_NumPIDs := $1, _MaxSeconds := $2)');
my $Dispatch               = $DispatchDatabaseHandle->prepare('SELECT RunProcessID, RunInSeconds, MaxProcesses, ConnectionPoolID, KillIfWaiting FROM cron.Dispatch()');

unless ($DispatchDatabaseHandle->{pg_user} eq 'pgcronjob') {
    die "Not connected as the 'pgcronjob' database user!";
}

while (1) {
    $Terminate_All_Backends->execute();
    my ($OK) = $Terminate_All_Backends->fetchrow_array();
    if ($OK) {
        # all cron.Run() processes have now been terminated
        last;
    } else {
        tprint("Waiting for old cron processes to be terminated");
        sleep(1); # wait for processes to be terminated
    }
}
$Reset_RunAtTime->execute();

my $LISTENDatabaseHandle = DBI->connect(@LISTENConnect) or die "Unable to connect LISTEN database handle";
$LISTENDatabaseHandle->do(qq{LISTEN "$LISTENName"}) or die "Unable to LISTEN: " . $LISTENDatabaseHandle->errstr;

tprint("PgCronJob is now running");

my $DispatchTime = time();
my $NumProcesses = {};
my $WaitingPIDsSeconds = {};

sub DumpState {
    tprint("ConnectTime: $ConnectTime\n"
        . "DispatchTime: $DispatchTime\n"
        . "NumProcesses:\n"
        . Dumper($NumProcesses)
        . "Processes:\n"
        . Dumper($Processes)
    );
}

$SIG{HUP} = \&DumpState;

while (1) {
    if (time() > $DispatchTime) {
        $Dispatch->execute();
        my ($RunProcessID, $RunInSeconds, $MaxProcesses, $ConnectionPoolID, $KillIfWaiting) = $Dispatch->fetchrow_array();
        if (defined $RunProcessID) {
            $Processes->{$RunProcessID} = {
                RunAtTime        => time() + $RunInSeconds,
                MaxProcesses     => $MaxProcesses,
                ConnectionPoolID => $ConnectionPoolID,
                KillIfWaiting    => $KillIfWaiting
            };
        } else {
            $DispatchTime = time()+1;
        }

        $Waiting_PIDs->execute();
        my ($PIDs) = $Waiting_PIDs->fetchrow_array();
        foreach my $PID (keys %{$WaitingPIDsSeconds}) {
            unless (grep {$_ eq $PID} @$PIDs) {
                delete $WaitingPIDsSeconds->{$PID};
            }
        }
        my $WaitingMaxSeconds = 0;
        foreach my $PID (@$PIDs) {
            $WaitingPIDsSeconds->{$PID} += 1;
            if ($WaitingPIDsSeconds->{$PID} > $WaitingMaxSeconds) {
                $WaitingMaxSeconds = $WaitingPIDsSeconds->{$PID};
            }
        }
        if (%$WaitingPIDsSeconds) {
            tprint("Waiting pg backends: " . join(', ', map{'[PID ' . $_ . ' ' . $WaitingPIDsSeconds->{$_} . ' secs]'} keys %$WaitingPIDsSeconds));
            $Log_Waiting->execute(scalar keys %$WaitingPIDsSeconds, $WaitingMaxSeconds);
            foreach my $ProcessID (keys %{$Processes}) {
                next unless (defined $Processes->{$ProcessID}->{KillIfWaiting} && defined !$Processes->{$ProcessID}->{RunAtTime} && $Processes->{$ProcessID}->{DatabaseHandle});
                if ($WaitingMaxSeconds > $Processes->{$ProcessID}->{KillIfWaiting}) {
                    tprint("Backends have been waiting for $WaitingMaxSeconds seconds which is longer than the limit of $Processes->{$ProcessID}->{KillIfWaiting} seconds, killing ProcessID $ProcessID with pg backend PID $Processes->{$ProcessID}->{PgBackendPID}");
                    $Terminate_Backend->execute($Processes->{$ProcessID}->{PgBackendPID});
                    $Processes->{$ProcessID}->{DatabaseHandle}->disconnect;
                    $Processes->{$ProcessID}->{DatabaseHandle} = undef;
                    if (defined $Processes->{$ProcessID}->{ConnectionPoolID}) {
                        $NumProcesses->{$Processes->{$ProcessID}->{ConnectionPoolID}}--;
                    }
                    delete $Processes->{$ProcessID};
                }
            }
        }
    }
    foreach my $ProcessID (sort {$Processes->{$a}->{RunAtTime} <=> $Processes->{$b}->{RunAtTime}} keys %{$Processes}) {
        my $Process = $Processes->{$ProcessID};
        my $RunAtTime         = \$Process->{RunAtTime};
        my $RunASAP           = \$Process->{RunASAP};
        my $MaxProcesses      = \$Process->{MaxProcesses};
        my $ConnectionPoolID  = \$Process->{ConnectionPoolID};
        my $RunDatabaseHandle = \$Process->{DatabaseHandle};
        my $Run               = \$Process->{Run};
        my $KillIfWaiting     = \$Process->{KillIfWaiting};
        if (defined $$ConnectionPoolID && !defined $NumProcesses->{$$ConnectionPoolID}) {
            $NumProcesses->{$$ConnectionPoolID} = 0;
        }
        if ($$RunAtTime) {
            if ($$RunAtTime > time() || (defined $$MaxProcesses && $$MaxProcesses ne '' && $NumProcesses->{$$ConnectionPoolID} >= $$MaxProcesses)) {
                next;
            }
            unless (defined $$RunDatabaseHandle) {
                $$RunDatabaseHandle = DBI->connect(@Connect) or die "Unable to connect";
                $Process->{PgBackendPID} = ${$RunDatabaseHandle}->{pg_pid};
                $$Run = ${$RunDatabaseHandle}->prepare(SQL_Run($ProcessID), {pg_async => PG_ASYNC});
            }
            $$Run->execute();
            $$RunAtTime = 0;
            if (defined $$ConnectionPoolID) {
                $NumProcesses->{$$ConnectionPoolID}++;
            }
        } elsif ($$Run->pg_ready) {
            if (defined $$ConnectionPoolID) {
                $NumProcesses->{$$ConnectionPoolID}--;
            }
            my $Rows = $$Run->pg_result;
            die "Unexpected number of rows: $Rows" unless $Rows == 1;
            my ($RunInSeconds) = $$Run->fetchrow_array();
            if (!defined $RunInSeconds || $RunInSeconds > $ConnectTime) {
                $$Run->finish;
                $$Run = undef;
                delete $Process->{Run};
                $$RunDatabaseHandle->disconnect;
                $$RunDatabaseHandle = undef;
                delete $Process->{DatabaseHandle};
                delete $Process->{PgBackendPID};
            }
            if (defined $RunInSeconds) {
                $$RunAtTime = time() + ($$RunASAP ? 0 : $RunInSeconds);
                $$RunASAP = undef;
            } else {
                delete $Processes->{$ProcessID};
            }
        }
    }
    while (my $NOTIFY = $LISTENDatabaseHandle->pg_notifies) {
        my ($NOTIFYName, $NOTIFYPID, $NOTIFYPayload) = @$NOTIFY;
        next unless $NOTIFYName eq $LISTENName && $NOTIFYPayload =~ m/^\d+$/;
        my $ProcessID = $NOTIFYPayload;
        next unless defined $Processes->{$ProcessID};
        if ($Processes->{$ProcessID}->{RunAtTime}) {
            $Processes->{$ProcessID}->{RunAtTime} = time();
        } else {
            $Processes->{$ProcessID}->{RunASAP} = 1;
        }
    }
    sleep(0.001); # sleep 1 ms to avoid 100% CPU usage
}
